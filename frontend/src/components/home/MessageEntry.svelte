<script lang="ts">
    import Send from "svelte-material-icons/Send.svelte";
    import ContentSaveEditOutline from "svelte-material-icons/ContentSaveMoveOutline.svelte";
    import Close from "svelte-material-icons/Close.svelte";
    import HoverIcon from "../HoverIcon.svelte";
    import AudioAttacher from "./AudioAttacher.svelte";
    import { emojiStore } from "../../stores/emoji";
    import { createEventDispatcher } from "svelte";
    import { _ } from "svelte-i18n";
    import Progress from "../Progress.svelte";
    import type { ChatController } from "../../fsm/chat.controller";
    import { iconSize } from "../../stores/iconSize";
    import { ScreenWidth, screenWidth } from "../../stores/screenDimensions";
    import { validateTokenInput } from "../../utils/cryptoFormatter";
    import { audioRecordingMimeType } from "../../utils/media";
    import MentionPicker from "./MentionPicker.svelte";
    import { userStore } from "stores/user";
    import EmojiAutocompleter from "./EmojiAutocompleter.svelte";
    import type { PartialUserSummary, User } from "../../domain/user/user";
    import Button from "../Button.svelte";
    import type { GroupChatSummary, MessageAction } from "../../domain/chat/chat";
    import { enterSend } from "../../stores/settings";
    import MessageActions from "./MessageActions.svelte";
    import { addQueryStringParam } from "utils/urls";
    import { allQuestions, Questions } from "../../domain/faq";

    export let controller: ChatController;
    export let blocked: boolean;
    export let preview: boolean;
    export let canSend: boolean;
    export let messageAction: MessageAction = undefined;
    export let joining: GroupChatSummary | undefined;

    $: textContent = controller.textContent;
    $: editingEvent = controller.editingEvent;
    $: fileToAttach = controller.fileToAttach;
    $: participants = controller.participants;
    $: blockedUsers = controller.blockedUsers;
    $: replyingTo = controller.replyingTo;

    const USER_TYPING_EVENT_MIN_INTERVAL_MS = 1000; // 1 second
    const MARK_TYPING_STOPPED_INTERVAL_MS = 5000; // 5 seconds

    const reverseUserLookup: Record<string, string> = {};
    const mentionRegex = /@([\d\w_]*)$/;
    const emojiRegex = /:([\w_]+):?$/;
    const dispatch = createEventDispatcher();
    let inp: HTMLDivElement;
    let audioMimeType = audioRecordingMimeType();
    let selectedRange: Range | undefined;
    let dragging: boolean = false;
    let recording: boolean = false;
    let percentRecorded: number = 0;
    let initialisedEdit: boolean = false;
    let lastTypingUpdate: number = 0;
    let typingTimer: number | undefined = undefined;
    let audioSupported: boolean = "mediaDevices" in navigator;
    let showMentionPicker = false;
    let showEmojiSearch = false;
    let mentionPrefix: string | undefined;
    let emojiQuery: string | undefined;
    let messageEntryHeight: number;
    let messageActions: MessageActions;
    let rangeToReplace: [number, number] | undefined = undefined;

    $: messageIsEmpty = ($textContent?.trim() ?? "").length === 0 && $fileToAttach === undefined;

    $: {
        if ($editingEvent && !initialisedEdit) {
            if ($editingEvent.event.content.kind === "text_content") {
                inp.textContent = formatMentions($editingEvent.event.content.text);
                selectedRange = undefined;
                restoreSelection();
                initialisedEdit = true;
            } else if ("caption" in $editingEvent.event.content) {
                inp.textContent = $editingEvent.event.content.caption ?? "";
                selectedRange = undefined;
                restoreSelection();
                initialisedEdit = true;
            }
        } else if (inp) {
            const text = $textContent ?? "";
            // Only set the textbox text when required rather than every time, because doing so sets the focus back to
            // the start of the textbox on some devices.
            if (inp.textContent !== text) {
                inp.textContent = text;
                setCaretToEnd();
            }
        }
        if ($editingEvent === undefined) {
            initialisedEdit = false;
        }
    }

    $: {
        if ($fileToAttach !== undefined || $replyingTo !== undefined) {
            inp?.focus();
        }
    }

    $: {
        if (controller && $screenWidth === ScreenWidth.Large) {
            inp?.focus();
        }
    }

    $: {
        if ($emojiStore !== undefined) {
            if (inp) {
                restoreSelection();
                document.execCommand("insertText", false, $emojiStore);
                messageIsEmpty = false;
                saveSelection();
                emojiStore.set(undefined);
            }
        }
    }

    // todo - doubt this will react properly
    $: placeholder =
        $fileToAttach !== undefined
            ? $_("enterCaption")
            : dragging
            ? $_("dropFile")
            : $_("enterMessage");

    export function insertTextAtCaret(text: string) {
        inp?.focus();
        let range = window.getSelection()?.getRangeAt(0);
        if (range !== undefined) {
            range.deleteContents();
            range.insertNode(document.createTextNode(text));
            range.collapse(false);
            const inputContent = inp.textContent ?? "";
            controller.setTextContent(inputContent.trim().length === 0 ? undefined : inputContent);
        }
    }

    function onInput() {
        const inputContent = inp.textContent ?? "";
        controller.setTextContent(inputContent.trim().length === 0 ? undefined : inputContent);
        triggerMentionLookup(inputContent);
        triggerEmojiLookup(inputContent);
        triggerTypingTimer();
    }

    function uptoCaret(
        inputContent: string | null,
        fn: (slice: string, pos: number) => void
    ): void {
        if (inputContent === null) return;

        const pos = window.getSelection()?.anchorOffset;
        if (pos === undefined) return;

        const slice = inputContent.slice(0, pos);
        fn(slice, pos);
    }

    function triggerEmojiLookup(inputContent: string | null): void {
        uptoCaret(inputContent, (slice: string, pos: number) => {
            const matches = slice.match(emojiRegex);
            if (matches !== null) {
                if (matches.index !== undefined) {
                    rangeToReplace = [matches.index, pos];
                    emojiQuery = matches[1].toLowerCase() || undefined;
                    showEmojiSearch = true;
                }
            } else {
                showEmojiSearch = false;
                emojiQuery = undefined;
            }
        });
    }

    function triggerMentionLookup(inputContent: string | null): void {
        uptoCaret(inputContent, (slice: string, pos: number) => {
            const matches = slice.match(mentionRegex);
            if (matches !== null) {
                if (matches.index !== undefined) {
                    rangeToReplace = [matches.index, pos];
                    mentionPrefix = matches[1].toLowerCase() || undefined;
                    showMentionPicker = true;
                }
            } else {
                showMentionPicker = false;
                mentionPrefix = undefined;
            }
        });
    }

    function triggerTypingTimer() {
        requestAnimationFrame(() => {
            const now = Date.now();
            if (now - lastTypingUpdate > USER_TYPING_EVENT_MIN_INTERVAL_MS) {
                lastTypingUpdate = now;
                controller.startTyping();
            }
            if (typingTimer !== undefined) {
                clearTimeout(typingTimer);
            }

            typingTimer = setTimeout(
                () => controller.stopTyping(),
                MARK_TYPING_STOPPED_INTERVAL_MS
            );
        });
    }

    function keyPress(e: KeyboardEvent) {
        if (e.key === "Enter" && $enterSend && !e.shiftKey) {
            if (!messageIsEmpty) {
                sendMessage();
                controller.stopTyping();
            }
            e.preventDefault();
        }
    }

    function formatMentions(text: string): string {
        return text.replace(/@UserId\(([\d\w-]+)\)/g, (match, p1) => {
            const u = $userStore[p1] as PartialUserSummary | undefined;
            if (u?.username !== undefined) {
                const username = u.username;
                reverseUserLookup[username] = u.userId;
                return `@${username}`;
            }
            return match;
        });
    }

    // replace anything of the form @username with @UserId(xyz) where xyz is the userId
    // if we don't have the mapping, just leave it as is (we *will* have the mapping)
    function expandMentions(text?: string): [string | undefined, User[]] {
        let mentionedMap = new Map<string, string>();
        let expandedText = text?.replace(/@([\w\d_]*)/g, (match, p1) => {
            const userId = reverseUserLookup[p1];
            if (userId !== undefined) {
                mentionedMap.set(userId, p1);
                return `@UserId(${userId})`;
            } else {
                console.log(
                    `Could not find the userId for user: ${p1}, this should not really happen`
                );
            }
            return match;
        });

        let mentioned = Array.from(mentionedMap, ([userId, username]) => ({ userId, username }));

        return [expandedText, mentioned];
    }

    /**
     * Check the message content for special commands
     * * !poll - creates a poll
     * * !icp [amount]
     * * !search [term]
     * * !pinned - opens pinned messages (not yet)
     * * !details - opens group details (not yet)
     */
    function parseCommands(txt: string): boolean {
        if (/^\/poll$/.test(txt)) {
            dispatch("createPoll");
            return true;
        }

        const searchMatch = txt.match(/^\/search( *(.*))$/);
        if (searchMatch && searchMatch[2] !== undefined) {
            dispatch("searchChat", searchMatch[2]);
            return true;
        }

        const gifMatch = txt.match(/^\/gif( *(.*))$/);
        if (gifMatch && gifMatch[2] !== undefined) {
            dispatch("attachGif", gifMatch[2]);
            return true;
        }

        if (controller.chatVal.kind === "group_chat") {
            const faqMatch = txt.match(/^\/faq( *(.*))$/);
            if (faqMatch && faqMatch[2] !== undefined) {
                if (allQuestions.includes(faqMatch[2] as Questions)) {
                    const url = addQueryStringParam(new URLSearchParams(), "faq", faqMatch[2]);
                    dispatch("sendMessage", [
                        `[🤔 FAQ: ${$_(`faq.${faqMatch[2]}_q`)}](#${url})`,
                        [],
                    ]);
                } else {
                    const url = addQueryStringParam(new URLSearchParams(), "faq", "");
                    dispatch("sendMessage", [`[🤔 FAQs](#${url})`, []]);
                }
                return true;
            }
        }

        const tokenMatch = process.env.ENABLE_MULTI_CRYPTO
            ? txt.match(/^\/(icp|btc|chat) *(\d*[.,]?\d*)$/)
            : txt.match(/^\/(icp) *(\d*[.,]?\d*)$/);
        if (tokenMatch && tokenMatch[2] !== undefined) {
            dispatch("tokenTransfer", {
                token: tokenMatch[1],
                amount: validateTokenInput(tokenMatch[2]).e8s,
            });
            return true;
        }
        return false;
    }

    function cancelEdit() {
        controller.cancelEditEvent();
    }

    function sendMessage() {
        const txt = inp.innerText?.trim();

        if (!parseCommands(txt)) {
            dispatch("sendMessage", expandMentions(txt));
        }
        inp.textContent = "";
        controller.setTextContent(undefined);
        inp.focus();
        messageActions.close();
    }

    function saveSelection() {
        try {
            // seeing errors in the logs to do with this
            selectedRange = window.getSelection()?.getRangeAt(0);
        } catch (_err) {}
    }

    function restoreSelection() {
        inp.focus();
        if (!selectedRange) {
            const range = new Range();
            range.selectNodeContents(inp);
            range.collapse(false);
            selectedRange = range;
        }

        const selection = window.getSelection()!;
        selection.removeAllRanges();
        selection.addRange(selectedRange);
    }

    function setCaretToEnd() {
        const range = document.createRange();
        range.selectNodeContents(inp);
        range.collapse(false);
        const sel = window.getSelection();
        sel?.removeAllRanges();
        sel?.addRange(range);
    }

    function setCaretTo(pos: number) {
        const range = document.createRange();
        range.selectNodeContents(inp);
        range.setStart(inp.childNodes[0], pos);
        range.collapse(true);
        const sel = window.getSelection();
        sel?.removeAllRanges();
        sel?.addRange(range);
    }

    function onDrop(e: DragEvent) {
        dragging = false;
        dispatch("drop", e);
    }

    function replaceTextWith(replacement: string) {
        if (rangeToReplace === undefined) return;

        const replaced = `${inp.textContent?.slice(
            0,
            rangeToReplace[0]
        )}${replacement} ${inp.textContent?.slice(rangeToReplace[1])}`;
        inp.textContent = replaced;

        controller.setTextContent(inp.textContent || undefined);
        setCaretTo(rangeToReplace[0] + replacement.length);
        rangeToReplace = undefined;
    }

    function mention(ev: CustomEvent<string>): void {
        const user = $userStore[ev.detail];
        const username = user?.username ?? $_("unknown");
        const userLabel = `@${username}`;

        replaceTextWith(userLabel);

        showMentionPicker = false;
        if (user !== undefined) {
            reverseUserLookup[username] = user.userId;
        }
    }

    function cancelMention() {
        showMentionPicker = false;
        setCaretToEnd();
    }

    function completeEmoji(ev: CustomEvent<string>) {
        replaceTextWith(ev.detail);
        showEmojiSearch = false;
    }

    function joinGroup() {
        dispatch("joinGroup", {
            group: controller.chatVal,
            select: true,
        });
    }

    function cancelPreview() {
        dispatch("cancelPreview", controller.chatId);
    }
</script>

{#if showMentionPicker}
    <MentionPicker
        blockedUsers={$blockedUsers}
        offset={messageEntryHeight}
        on:close={cancelMention}
        on:mention={mention}
        prefix={mentionPrefix}
        participants={$participants} />
{/if}

{#if showEmojiSearch}
    <EmojiAutocompleter
        offset={messageEntryHeight}
        on:close={() => (showEmojiSearch = false)}
        on:select={completeEmoji}
        query={emojiQuery} />
{/if}

<div
    class="message-entry"
    class:editing={$editingEvent !== undefined}
    bind:clientHeight={messageEntryHeight}>
    {#if blocked}
        <div class="blocked">
            {$_("userIsBlocked")}
        </div>
    {:else if preview}
        <div class="preview">
            <Button secondary={true} small={true} on:click={cancelPreview}>
                {$_("leave")}
            </Button>
            <Button
                loading={joining !== undefined}
                disabled={joining !== undefined}
                small={true}
                on:click={joinGroup}>
                {$_("joinGroup")}
            </Button>
        </div>
    {:else if !canSend}
        <div class="disabled">
            {$_("readOnlyChat")}
        </div>
    {:else}
        <MessageActions
            bind:this={messageActions}
            bind:messageAction
            {controller}
            editing={$editingEvent !== undefined}
            on:tokenTransfer
            on:attachGif
            on:fileSelected />

        {#if recording}
            <div class="recording">
                <Progress percent={percentRecorded} />
            </div>
        {/if}
        <div
            tabindex={0}
            bind:this={inp}
            on:blur={saveSelection}
            class="textbox"
            class:recording
            class:dragging
            contenteditable={true}
            on:paste
            {placeholder}
            spellcheck={true}
            on:dragover={() => (dragging = true)}
            on:dragenter={() => (dragging = true)}
            on:dragleave={() => (dragging = false)}
            on:drop={onDrop}
            on:input={onInput}
            on:keypress={keyPress} />
        {#if $editingEvent === undefined}
            {#if messageIsEmpty && audioMimeType !== undefined && audioSupported}
                <div class="record">
                    <AudioAttacher
                        mimeType={audioMimeType}
                        bind:percentRecorded
                        bind:recording
                        bind:supported={audioSupported}
                        on:audioCaptured />
                </div>
            {:else}
                <div class="send" on:click={sendMessage}>
                    <HoverIcon>
                        <Send size={$iconSize} color={"var(--icon-txt)"} />
                    </HoverIcon>
                </div>
            {/if}
        {:else}
            <div class="send" on:click={sendMessage}>
                <HoverIcon>
                    <ContentSaveEditOutline size={$iconSize} color={"var(--button-txt)"} />
                </HoverIcon>
            </div>
            <div class="send" on:click={cancelEdit}>
                <HoverIcon>
                    <Close size={$iconSize} color={"var(--button-txt)"} />
                </HoverIcon>
            </div>
        {/if}
    {/if}
</div>

<style type="text/scss">
    .message-entry {
        position: relative;
        flex: 0 0 toRem(40);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: var(--entry-bg);
        padding: $sp3;

        &.editing {
            background-color: var(--button-bg);
        }
    }
    .send {
        flex: 0 0 15px;
    }
    .textbox {
        flex: 1;
        margin: 0 $sp3;
        padding: 6px $sp4;
        background-color: var(--entry-input-bg);
        color: var(--entry-input-txt);
        border-radius: 20px;
        outline: none;
        border: 0;
        max-height: 100px;
        min-height: toRem(30);
        overflow-x: hidden;
        overflow-y: auto;
        user-select: text;
        white-space: pre-wrap;
        overflow-wrap: anywhere;
        border: 1px solid transparent;
        @include font(book, normal, fs-100);

        &:empty:before {
            content: attr(placeholder);
            color: var(--placeholder);
            pointer-events: none;
            display: block; /* For Firefox */
        }

        &.dragging {
            border: 1px dashed var(--entry-input-txt);
        }

        &.recording {
            display: none;
        }
    }

    .blocked,
    .disabled,
    .preview {
        height: 42px;
        color: var(--entry-input-txt);
        @include font(book, normal, fs-100);
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
    }

    .preview {
        justify-content: flex-end;
        gap: $sp3;
        @include mobile() {
            justify-content: center;
        }
    }

    .recording {
        padding: 0 $sp3;
        flex: auto;
    }
</style>
