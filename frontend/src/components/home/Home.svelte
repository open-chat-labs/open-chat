<script lang="ts">
    import BackgroundLogo from "../BackgroundLogo.svelte";
    import { _ } from "svelte-i18n";
    import LeftPanel from "./LeftPanel.svelte";
    import Toast from "../Toast.svelte";
    import AboutModal from "../AboutModal.svelte";
    import FaqModal from "../FaqModal.svelte";
    import RoadmapModal from "../RoadmapModal.svelte";
    import SelectChatModal from "../SelectChatModal.svelte";
    import MiddlePanel from "./MiddlePanel.svelte";
    import RightPanel from "./RightPanel.svelte";
    import { fly } from "svelte/transition";
    import type { Notification } from "../../domain/notifications";
    import Overlay from "../Overlay.svelte";
    import { onMount, setContext, tick } from "svelte";
    import { rtlStore } from "../../stores/rtl";
    import {
        dimensions,
        mobileWidth,
        screenWidth,
        ScreenWidth,
    } from "../../stores/screenDimensions";
    import { push, replace, querystring } from "svelte-spa-router";
    import { sineInOut } from "svelte/easing";
    import { toastStore } from "../../stores/toast";
    import type {
        GroupSearchResponse,
        MessageMatch,
        SearchAllMessagesResponse,
    } from "../../domain/search/search";
    import type { CreatedUser, UserSummary } from "../../domain/user/user";
    import { blockedUsers } from "../../stores/blockedUsers";
    import { rtcConnectionsManager } from "../../domain/webrtc/RtcConnectionsManager";
    import { userStore } from "../../stores/user";
    import { initNotificationStores } from "../../stores/notifications";
    import { filterByChatType, RightPanelState } from "../../fsm/rightPanel";
    import { rollbar } from "../../utils/logging";
    import type {
        ChatSummary,
        EnhancedReplyContext,
        EventWrapper,
        GroupChatSummary,
        MemberRole,
        Message,
    } from "../../domain/chat/chat";
    import { currentUserKey } from "../../stores/user";
    import { mapRemoteData } from "../../utils/remoteData";
    import type { RemoteData } from "../../utils/remoteData";
    import Upgrade from "./upgrade/Upgrade.svelte";
    import type { Questions } from "../../domain/faq";
    import { apiKey, ServiceContainer } from "../../services/serviceContainer";
    import type { Share } from "../../domain/share";
    import { draftMessages } from "../../stores/draftMessages";
    import AreYouSure from "../AreYouSure.svelte";
    import { removeQueryStringParam } from "../../utils/urls";
    import {
        canSendMessages,
        mergeChatMetrics,
        userIdsFromEvents,
    } from "../../domain/chat/chat.utils";
    import { emptyChatMetrics } from "../../domain/chat/chat.utils.shared";
    import { trackEvent } from "../../utils/tracking";
    import { numberOfColumns, oldLayout } from "../../stores/layout";
    import { messageToForwardStore } from "../../stores/messageToForward";
    import {
        chatSummariesListStore,
        chatSummariesStore,
        chatsLoading,
        selectedChatStore,
        chatsInitialised,
        createDirectChat,
        setSelectedChat,
        serverChatSummariesStore,
        currentUserStore,
        removeChat,
        updateSummaryWithConfirmedMessage,
        clearSelectedChat,
    } from "../../stores/chat";
    import { setCachedMessageFromNotification } from "../../utils/caching";
    import { missingUserIds } from "../../domain/user/user.utils";
    import { handleWebRtcMessage } from "../../domain/webrtc/rtcHandler";
    import { startPruningLocalReactions } from "../../stores/reactions";
    import { pinnedChatsStore } from "../../stores/pinnedChats";

    export let api: ServiceContainer;
    export let user: CreatedUser;
    export let logout: () => void;

    export let params: { chatId: string | null; messageIndex: string | undefined | null } = {
        chatId: null,
        messageIndex: undefined,
    };

    type ConfirmAction = "leave" | "delete" | "makePrivate";
    type ConfirmActionEvent = {
        kind: ConfirmAction;
        chatId: string;
        doubleCheck: { challenge: string; response: string } | undefined;
    };

    enum ModalType {
        None,
        About,
        Faq,
        Roadmap,
        SelectChat,
    }

    let faqQuestion: Questions | undefined = undefined;
    let modal = ModalType.None;
    setContext(apiKey, api);
    setContext(currentUserKey, user);

    let groupSearchResults: Promise<GroupSearchResponse> | undefined = undefined;
    let userSearchResults: Promise<UserSummary[]> | undefined = undefined;
    let messageSearchResults: Promise<SearchAllMessagesResponse> | undefined = undefined;
    let searchTerm: string = "";
    let searching: boolean = false;
    let searchResultsAvailable: boolean = false;
    let confirmActionEvent: ConfirmActionEvent | undefined;
    let hotGroups: RemoteData<GroupChatSummary[], string> = { kind: "idle" };
    let joining: GroupChatSummary | undefined = undefined;
    let upgradeStorage: "explain" | "icp" | "sms" | undefined = undefined;
    let share: Share = { title: "", text: "", url: "", files: [] };
    let interruptRecommended = false;
    let rightPanelHistory: RightPanelState[] = [];
    let messageToForward: Message | undefined = undefined;
    let modalMessage = "";

    $: selectedThreadMessageIndex = rightPanelHistory.reduce<number | undefined>(
        (_, s) => (s.kind === "message_thread_panel" ? s.rootEvent.event.messageIndex : undefined),
        undefined
    );
    $: userId = user.userId;
    $: wasmVersion = user.wasmVersion;
    $: qs = new URLSearchParams($querystring);
    $: confirmMessage = getConfirmMessage(confirmActionEvent);
    $: combinedMetrics = $chatSummariesListStore
        .map((c) => c.myMetrics)
        .reduce(mergeChatMetrics, emptyChatMetrics());
    $: chat = $selectedChatStore?.chat;
    $: x = $rtlStore ? -500 : 500;
    $: rightPanelSlideDuration = $mobileWidth ? 0 : 200;
    $: blocked = chat && $chat && $chat.kind === "direct_chat" && $blockedUsers.has($chat.them);

    /** SHOW LEFT
     * MobileScreen  |  ChatSelected  |  ShowingRecs  |  ShowLeft
     * ==========================================================
     * F             |  -            |  -            |  T
     * T             |  T            |  -            |  F
     * T             |  F            |  T            |  F
     * T             |  F            |  F            |  T
     */
    $: showLeft =
        !$mobileWidth || ($mobileWidth && params.chatId == null && hotGroups.kind === "idle");

    /** SHOW MIDDLE
     * SmallScreen  |  ChatSelected  |  ShowingRecs  |  ShowLeft
     * ==========================================================
     * F             |  -            |  -            |  T
     * T             |  T            |  -            |  T
     * T             |  F            |  T            |  T
     * T             |  F            |  F            |  F
     */
    $: showMiddle =
        !$mobileWidth ||
        ($mobileWidth && params.chatId != null) ||
        ($mobileWidth && params.chatId == null && hotGroups.kind !== "idle");

    onMount(() => {
        // bootstrap anything that needs a service container here
        rtcConnectionsManager.init(user.userId);
        rtcConnectionsManager.subscribe((msg) => handleWebRtcMessage(msg));
        initNotificationStores(api, user.userId, (n) => notificationReceived(n));
        startPruningLocalReactions();
    });

    $: {
        // wait until we have loaded the chats
        if ($chatsInitialised) {
            if (params.chatId === "share") {
                const local_qs = new URLSearchParams(window.location.search);
                const title = local_qs.get("title") ?? "";
                const text = local_qs.get("text") ?? "";
                const url = local_qs.get("url") ?? "";
                share = {
                    title,
                    text,
                    url,
                    files: [],
                };
                params.chatId = null;
                history.replaceState(null, "", "/#/");
                modal = ModalType.SelectChat;
            }

            // if we have a chatid in the params then we need to select that chat
            if (params.chatId && params.chatId !== $selectedChatStore?.chatId?.toString()) {
                // if the chat in the param is not known to us then we need to attempt to load the
                // chat on the assumption that it is a group we want to preview
                // if we have an unknown chat in the param, then redirect to home
                const chatId = params.chatId;
                const messageIndex =
                    params.messageIndex == null ? undefined : Number(params.messageIndex);

                if ($chatSummariesStore[chatId] === undefined) {
                    if (qs.get("type") === "direct") {
                        createDirectChat(chatId);
                    } else {
                        const code = qs.get("code");
                        if (code) {
                            api.groupInvite = {
                                chatId,
                                code,
                            };
                        }

                        hotGroups = { kind: "loading" };
                        previewChat(chatId).then((canPreview) => {
                            if (canPreview) {
                                setSelectedChat(api, chatId, messageIndex);
                                resetRightPanel();
                                hotGroups = { kind: "idle" };
                            } else {
                                replace("/");
                            }
                        });
                    }
                } else {
                    hotGroups = { kind: "idle" };
                    interruptRecommended = true;
                    setSelectedChat(api, chatId, messageIndex);
                    resetRightPanel();
                }
            }

            if (
                params.chatId &&
                params.messageIndex &&
                params.chatId === $selectedChatStore?.chatId?.toString()
            ) {
                $selectedChatStore?.goToMessageIndex(Number(params.messageIndex), false);
            }

            const faq = qs.get("faq");
            if (faq !== null) {
                faqQuestion = faq as Questions;
                modal = ModalType.Faq;
                replace(removeQueryStringParam(qs, "faq"));
            }

            // if there is no chatId param, tell the machine to clear the selection
            if (params.chatId === null && $selectedChatStore !== undefined) {
                clearSelectedChat();
            }

            if (params.chatId === null && !$mobileWidth && hotGroups.kind === "idle") {
                whatsHot();
            }

            if (params.chatId === null) {
                rightPanelHistory = rightPanelHistory.filter(
                    (panel) => panel.kind === "user_profile" || panel.kind === "new_group_panel"
                );
            }
        }
    }

    /**
     * We may wish to look at chats without joining them.
     * If the chat is either a public group or a private group with an invite code then
     * we load the chat summary directly.
     * We will then add that chat to our chat list locally with a custom role of "Previewer"
     * This will allow us to interact with the chat in a readonly mode.
     *
     * We will load the chat and then add it to the chat list. If we refresh the page
     * it will just disppear (unless of course we still have the canisterId in the url)
     */
    function previewChat(chatId: string): Promise<boolean> {
        return api.getPublicGroupSummary(chatId).then((maybeChat) => {
            if (maybeChat === undefined) {
                return false;
            }
            addOrReplaceChat(maybeChat);
            return true;
        });
    }

    function addOrReplaceChat(chat: ChatSummary): void {
        serverChatSummariesStore.update((summaries) => {
            return {
                ...summaries,
                [chat.chatId]: chat,
            };
        });
    }

    function notificationReceived(notification: Notification): void {
        let chatId: string;
        let message: EventWrapper<Message>;
        switch (notification.kind) {
            case "direct_notification": {
                chatId = notification.sender;
                message = notification.message;
                break;
            }
            case "group_notification": {
                chatId = notification.chatId;
                message = notification.message;
                break;
            }
            case "added_to_group_notification":
                return;
        }

        const chat = $chatSummariesStore[chatId];
        if (chat === undefined) {
            return;
        }
        const chatType = chat.kind === "direct_chat" ? "direct" : "group";
        setCachedMessageFromNotification(notification);
        Promise.all([
            api.rehydrateMessage(chatType, chatId, message),
            addMissingUsersFromMessage(message),
        ]).then(([m, _]) => {
            updateSummaryWithConfirmedMessage(chatId, m);

            const selectedChat = $selectedChatStore;
            if (selectedChat?.chatId === chatId) {
                selectedChat?.handleMessageSentByOther(m, true);
            }
        });
    }

    async function addMissingUsersFromMessage(message: EventWrapper<Message>): Promise<void> {
        const users = userIdsFromEvents([message]);
        const missingUsers = missingUserIds($userStore, users);
        if (missingUsers.length > 0) {
            const usersResp = await api.getUsers(
                {
                    userGroups: [
                        {
                            users: missingUsers,
                            updatedSince: BigInt(0),
                        },
                    ],
                },
                true
            );
            userStore.addMany(usersResp.users);
        }
    }

    function resetRightPanel() {
        rightPanelHistory = filterByChatType(rightPanelHistory, $selectedChatStore?.chatVal);
    }

    function userAvatarSelected(ev: CustomEvent<{ url: string; data: Uint8Array }>): void {
        const data = {
            blobData: ev.detail.data,
            blobUrl: ev.detail.url,
        };
        user = {
            ...user,
            ...data,
        };
        currentUserStore.set(user);

        const partialUser = $userStore[user.userId];
        if (partialUser) {
            userStore.add({
                ...partialUser,
                ...data,
            });
        }

        api
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            .setUserAvatar(data.blobData!)
            .then((_resp) => toastStore.showSuccessToast("avatarUpdated"))
            .catch((err) => {
                rollbar.error("Failed to update user's avatar", err);
                toastStore.showFailureToast("avatarUpdateFailed");
            });
    }

    function goToMessageIndex(ev: CustomEvent<{ index: number; preserveFocus: boolean }>) {
        $selectedChatStore?.goToMessageIndex(ev.detail.index, ev.detail.preserveFocus);
    }

    function closeModal() {
        modal = ModalType.None;
    }

    function cancelRecommendations() {
        hotGroups = { kind: "idle" };
    }

    function dismissRecommendation(ev: CustomEvent<string>) {
        hotGroups = mapRemoteData(hotGroups, (data) => data.filter((g) => g.chatId !== ev.detail));
        api.dismissRecommendation(ev.detail);
    }

    function showFaqQuestion(ev: CustomEvent<Questions>) {
        faqQuestion = ev.detail;
        modal = ModalType.Faq;
    }

    async function performSearch(ev: CustomEvent<string>) {
        searchResultsAvailable = false;
        searchTerm = ev.detail;
        if (searchTerm !== "") {
            searching = true;
            const lowercase = searchTerm.toLowerCase();
            groupSearchResults = api.searchGroups(lowercase, 10);
            userSearchResults = api.searchUsers(lowercase, 10).then((resp) => {
                userStore.addMany(resp);
                return resp;
            });
            messageSearchResults = api.searchAllMessages(lowercase, 10);
            try {
                await Promise.all([
                    groupSearchResults,
                    userSearchResults,
                    messageSearchResults,
                ]).then(() => {
                    if (searchTerm !== "") {
                        searchResultsAvailable = true;
                        searching = false;
                    } else {
                        clearSearch();
                    }
                });
            } catch (_err) {
                searching = false;
            }
        } else {
            clearSearch();
        }
    }

    function clearSearch() {
        groupSearchResults = userSearchResults = messageSearchResults = undefined;
        searchTerm = "";
        searching = false;
        searchResultsAvailable = false;
    }

    function blockUser(ev: CustomEvent<{ userId: string }>) {
        blockedUsers.add(ev.detail.userId);
        api.blockUserFromDirectChat(ev.detail.userId)
            .then((resp) => {
                if (resp === "success") {
                    toastStore.showSuccessToast("blockUserSucceeded");
                } else {
                    toastStore.showFailureToast("blockUserFailed");
                }
            })
            .catch((err) => {
                toastStore.showFailureToast("blockUserFailed");
                rollbar.error("Error blocking user", err);
                blockedUsers.delete(ev.detail.userId);
            });
    }

    function unblockUser(ev: CustomEvent<{ userId: string }>) {
        blockedUsers.delete(ev.detail.userId);
        api.unblockUserFromDirectChat(ev.detail.userId)
            .then((resp) => {
                if (resp === "success") {
                    toastStore.showSuccessToast("unblockUserSucceeded");
                } else {
                    toastStore.showFailureToast("unblockUserFailed");
                }
            })
            .catch((err) => {
                toastStore.showFailureToast("unblockUserFailed");
                rollbar.error("Error unblocking user", err);
                blockedUsers.add(ev.detail.userId);
            });
    }

    function pinChat(ev: CustomEvent<string>) {
        const pinnedChatLimit = 5;
        if ($pinnedChatsStore.length >= pinnedChatLimit) {
            toastStore.showSuccessToast("pinChat.limitExceeded", {
                values: { limit: pinnedChatLimit },
            });
            return;
        }

        const chatId = ev.detail;
        pinnedChatsStore.pin(chatId);
        api.pinChat(chatId)
            .then((resp) => {
                if (resp.kind === "pinned_limit_reached") {
                    toastStore.showFailureToast("pinChat.limitExceeded", {
                        values: { limit: resp.limit },
                    });
                    pinnedChatsStore.unpin(chatId);
                }
            })
            .catch((err) => {
                toastStore.showFailureToast("pinChat.failed");
                rollbar.error("Error pinning chat", err);
                pinnedChatsStore.unpin(chatId);
            });
    }

    function unpinChat(ev: CustomEvent<string>) {
        const chatId = ev.detail;
        pinnedChatsStore.unpin(chatId);
        api.unpinChat(chatId).catch((err) => {
            toastStore.showFailureToast("pinChat.unpinFailed");
            rollbar.error("Error unpinning chat", err);
            pinnedChatsStore.pin(chatId);
        });
    }

    function getConfirmMessage(confirmActionEvent: ConfirmActionEvent | undefined): string {
        if (confirmActionEvent === undefined) return "";

        switch (confirmActionEvent.kind) {
            case "leave":
                return $_("confirmLeaveGroup");
            case "delete":
                return $_("irreversible");
            case "makePrivate":
                return $_("confirmMakeGroupPrivate");
        }
    }

    function triggerConfirm(ev: CustomEvent<ConfirmActionEvent>) {
        confirmActionEvent = ev.detail;
    }

    function onConfirmAction(yes: boolean): Promise<void> {
        const result = yes ? doConfirmAction(confirmActionEvent!) : Promise.resolve();

        return result.finally(() => {
            confirmActionEvent = undefined;
        });
    }

    function doConfirmAction(confirmActionEvent: ConfirmActionEvent): Promise<void> {
        switch (confirmActionEvent.kind) {
            case "leave":
                return leaveGroup(confirmActionEvent.chatId);
            case "delete":
                return deleteGroup(confirmActionEvent.chatId).then((_) => {
                    rightPanelHistory = [];
                });
            case "makePrivate":
                return makeGroupPrivate(confirmActionEvent.chatId).then((_) => {
                    rightPanelHistory = [];
                });
            default:
                return Promise.reject();
        }
    }

    function makeGroupPrivate(chatId: string): Promise<void> {
        return api
            .makeGroupPrivate(chatId)
            .then((resp) => {
                if (resp === "success") {
                    serverChatSummariesStore.update((summaries) => {
                        const summary = summaries[chatId];
                        if (summary === undefined || summary.kind !== "group_chat") {
                            return summaries;
                        }

                        return {
                            ...summaries,
                            [chatId]: {
                                ...summary,
                                public: false,
                            },
                        };
                    });
                } else {
                    toastStore.showFailureToast("makeGroupPrivateFailed");
                }
            })
            .catch((err) => {
                toastStore.showFailureToast("makeGroupPrivateFailed");
                rollbar.error("Error making group private", err);
            });
    }

    function deleteGroup(chatId: string): Promise<void> {
        clearSelectedChat();
        return api
            .deleteGroup(chatId)
            .then((resp) => {
                if (resp === "success") {
                    toastStore.showSuccessToast("deleteGroupSuccess");
                    removeChat(chatId);
                } else {
                    rollbar.warn("Unable to delete group", resp);
                    toastStore.showFailureToast("deleteGroupFailure");
                    push(`/${chatId}`);
                }
            })
            .catch((err) => {
                toastStore.showFailureToast("deleteGroupFailure");
                rollbar.error("Unable to delete group", err);
                push(`/${chatId}`);
            });
    }

    function leaveGroup(chatId: string): Promise<void> {
        clearSelectedChat();
        return api
            .leaveGroup(chatId)
            .then((resp) => {
                if (resp === "success" || resp === "not_in_group" || resp === "group_not_found") {
                    toastStore.showSuccessToast("leftGroup");
                    removeChat(chatId);
                } else {
                    if (resp === "owner_cannot_leave") {
                        toastStore.showFailureToast("ownerCantLeave");
                    } else {
                        toastStore.showFailureToast("failedToLeaveGroup");
                    }
                    push(`/${chatId}`);
                }
            })
            .catch((err) => {
                toastStore.showFailureToast("failedToLeaveGroup");
                rollbar.error("Unable to leave group", err);
                push(`/${chatId}`);
            });
    }

    function deleteDirectChat(ev: CustomEvent<string>) {
        if (ev.detail === params.chatId) {
            clearSelectedChat();
        }
        tick().then(() => removeChat(ev.detail));
    }

    function chatWith(ev: CustomEvent<string>) {
        const chat = $chatSummariesListStore.find((c) => {
            return c.kind === "direct_chat" && c.them === ev.detail;
        });
        if (chat) {
            push(`/${chat.chatId}`);
        } else {
            createDirectChat(ev.detail);
        }
    }

    function loadMessage(ev: CustomEvent<MessageMatch>): void {
        if (ev.detail.chatId === $selectedChatStore?.chatId) {
            $selectedChatStore.externalGoToMessage(ev.detail.messageIndex);
        } else {
            push(`/${ev.detail.chatId}/${ev.detail.messageIndex}`);
        }
    }

    function addParticipants() {
        if ($selectedChatStore !== undefined) {
            rightPanelHistory = [...rightPanelHistory, { kind: "add_participants" }];
        }
    }

    function replyPrivatelyTo(ev: CustomEvent<EnhancedReplyContext>) {
        const chat = $chatSummariesListStore.find((c) => {
            return c.kind === "direct_chat" && c.them === ev.detail.sender?.userId;
        });
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const chatId = chat?.chatId ?? ev.detail.sender!.userId;
        draftMessages.delete(chatId);
        draftMessages.setReplyingTo(chatId, ev.detail);
        if (chat) {
            push(`/${chat.chatId}`);
        } else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            createDirectChat(ev.detail.sender!.userId);
        }
    }

    function forwardMessage(ev: CustomEvent<Message>) {
        messageToForward = ev.detail;
        modal = ModalType.SelectChat;
    }

    function showParticipants() {
        if ($selectedChatStore !== undefined) {
            rightPanelHistory = [...rightPanelHistory, { kind: "show_participants" }];
        }
    }

    function showProfile() {
        rightPanelHistory = [{ kind: "user_profile" }];
    }

    function replyInThread(ev: CustomEvent<{ rootEvent: EventWrapper<Message> }>) {
        if ($selectedChatStore !== undefined) {
            rightPanelHistory = [
                {
                    kind: "message_thread_panel",
                    rootEvent: ev.detail.rootEvent,
                },
            ];
        }
    }

    function showGroupDetails() {
        if ($selectedChatStore !== undefined) {
            rightPanelHistory = [
                {
                    kind: "group_details",
                },
            ];
        }
    }

    function updateChat(ev: CustomEvent<ChatSummary>) {
        addOrReplaceChat(ev.detail);
    }

    function showPinned() {
        if ($selectedChatStore !== undefined) {
            rightPanelHistory = [
                {
                    kind: "show_pinned",
                },
            ];
        }
    }

    function joinGroup(ev: CustomEvent<{ group: GroupChatSummary; select: boolean }>) {
        joining = ev.detail.group;
        const group = ev.detail.group;

        api.joinGroup(group.chatId)
            .then((resp) => {
                if (resp.kind === "group_chat") {
                    addOrReplaceChat(resp);
                    setSelectedChat(api, group.chatId, undefined);
                    return true;
                } else if (resp.kind === "already_in_group") {
                    addOrReplaceChat({
                        ...group,
                        myRole: "participant" as MemberRole,
                    });
                    setSelectedChat(api, group.chatId, undefined);
                    return true;
                } else {
                    if (resp.kind === "blocked") {
                        toastStore.showFailureToast("youreBlocked");
                    } else {
                        toastStore.showFailureToast("joinGroupFailed");
                    }
                    return false;
                }
            })
            .then((success) => {
                if (success && ev.detail.select) {
                    hotGroups = { kind: "idle" };
                    push(`/${ev.detail.group.chatId}`);
                }
            })
            .catch((err) => {
                rollbar.error("Unable to join group", err);
                toastStore.showFailureToast("joinGroupFailed");
                return false;
            })
            .finally(() => (joining = undefined));
    }

    function cancelPreview(ev: CustomEvent<string>) {
        clearSelectedChat();
        tick().then(() => {
            removeChat(ev.detail);
        });
    }

    function whatsHot() {
        clearSelectedChat();
        tick().then(() => {
            interruptRecommended = false;
            hotGroups = { kind: "loading" };
            api.getRecommendedGroups((_n: number) => interruptRecommended)
                .then((resp) => (hotGroups = { kind: "success", data: resp }))
                .catch((err) => (hotGroups = { kind: "error", error: err.toString() }));
        });
    }

    function upgrade(ev: CustomEvent<"explain" | "icp" | "sms">) {
        upgradeStorage = ev.detail;
    }

    function onSelectChat(ev: CustomEvent<string>) {
        closeModal();
        if (messageToForward !== undefined) {
            forwardToChat(ev.detail);
            messageToForward = undefined;
        } else {
            shareWithChat(ev.detail);
        }
    }

    function onCloseSelectChat() {
        closeModal();
        messageToForward = undefined;
    }

    function forwardToChat(chatId: string) {
        push(`/${chatId}`);
        messageToForwardStore.set(messageToForward);
    }

    function shareWithChat(chatId: string) {
        push(`/${chatId}`);

        const shareText = share.text ?? "";
        const shareTitle = share.title ?? "";
        const shareUrl = share.url ?? "";

        let text = shareText.length > 0 ? shareText : shareTitle;

        if (shareUrl.length > 0) {
            if (text.length > 0) {
                text += "\n";
            }
            text += shareUrl;
        }

        draftMessages.setTextContent(chatId, text);
    }

    function groupCreated(ev: CustomEvent<GroupChatSummary>) {
        addOrReplaceChat(ev.detail);
        if (ev.detail.public) {
            trackEvent("public_group_created");
        } else {
            trackEvent("private_group_created");
        }
        rightPanelHistory =
            $screenWidth === ScreenWidth.ExtraExtraLarge
                ? [
                      {
                          kind: "group_details",
                      },
                  ]
                : [];
    }

    function newGroup() {
        rightPanelHistory = [...rightPanelHistory, { kind: "new_group_panel" }];
    }

    function filterChatSelection(
        chats: ChatSummary[],
        selectedChatId: string | undefined
    ): ChatSummary[] {
        return chats.filter((c) => selectedChatId !== c.chatId && canSendMessages(c, $userStore));
    }

    $: bgHeight = $dimensions.height * 0.9;
    $: bgClip = (($dimensions.height - 32) / bgHeight) * 361;
</script>

<main class:old-layout={oldLayout}>
    {#if showLeft}
        <LeftPanel
            {api}
            {user}
            {groupSearchResults}
            {userSearchResults}
            {messageSearchResults}
            {searchTerm}
            {searchResultsAvailable}
            {searching}
            on:showAbout={() => (modal = ModalType.About)}
            on:showFaq={() => (modal = ModalType.Faq)}
            on:showRoadmap={() => (modal = ModalType.Roadmap)}
            on:searchEntered={performSearch}
            on:userAvatarSelected={userAvatarSelected}
            on:chatWith={chatWith}
            on:whatsHot={whatsHot}
            on:newGroup={newGroup}
            on:profile={showProfile}
            on:logout={logout}
            on:deleteDirectChat={deleteDirectChat}
            on:pinChat={pinChat}
            on:unpinChat={unpinChat}
            on:loadMessage={loadMessage} />
    {/if}
    {#if showMiddle}
        <MiddlePanel
            {hotGroups}
            {joining}
            {selectedThreadMessageIndex}
            loadingChats={$chatsLoading}
            blocked={!!blocked}
            controller={$selectedChatStore}
            on:clearSelection={clearSelectedChat}
            on:blockUser={blockUser}
            on:unblockUser={unblockUser}
            on:leaveGroup={triggerConfirm}
            on:chatWith={chatWith}
            on:replyPrivatelyTo={replyPrivatelyTo}
            on:addParticipants={addParticipants}
            on:showGroupDetails={showGroupDetails}
            on:replyInThread={replyInThread}
            on:showParticipants={showParticipants}
            on:updateChat={updateChat}
            on:joinGroup={joinGroup}
            on:cancelPreview={cancelPreview}
            on:cancelRecommendations={cancelRecommendations}
            on:recommend={whatsHot}
            on:dismissRecommendation={dismissRecommendation}
            on:upgrade={upgrade}
            on:showPinned={showPinned}
            on:goToMessageIndex={goToMessageIndex}
            on:forward={forwardMessage} />
    {/if}
    {#if $numberOfColumns === 3}
        <RightPanel
            {userId}
            controller={$selectedChatStore}
            metrics={combinedMetrics}
            bind:rightPanelHistory
            on:showFaqQuestion={showFaqQuestion}
            on:userAvatarSelected={userAvatarSelected}
            on:goToMessageIndex={goToMessageIndex}
            on:addParticipants={addParticipants}
            on:showParticipants={showParticipants}
            on:chatWith={chatWith}
            on:upgrade={upgrade}
            on:blockUser={blockUser}
            on:deleteGroup={triggerConfirm}
            on:makeGroupPrivate={triggerConfirm}
            on:updateChat={updateChat}
            on:groupCreated={groupCreated} />
    {/if}
</main>

{#if $numberOfColumns === 2 && rightPanelHistory.length > 0}
    <Overlay fade={!$mobileWidth}>
        <div
            transition:fly={{ x, duration: rightPanelSlideDuration, easing: sineInOut }}
            class="right-wrapper"
            class:rtl={$rtlStore}>
            <RightPanel
                {userId}
                controller={$selectedChatStore}
                metrics={combinedMetrics}
                bind:rightPanelHistory
                on:showFaqQuestion={showFaqQuestion}
                on:userAvatarSelected={userAvatarSelected}
                on:goToMessageIndex={goToMessageIndex}
                on:addParticipants={addParticipants}
                on:showParticipants={showParticipants}
                on:chatWith={chatWith}
                on:upgrade={upgrade}
                on:blockUser={blockUser}
                on:deleteGroup={triggerConfirm}
                on:makeGroupPrivate={triggerConfirm}
                on:updateChat={updateChat}
                on:groupCreated={groupCreated} />
        </div>
    </Overlay>
{/if}

{#if confirmActionEvent !== undefined}
    <AreYouSure
        doubleCheck={confirmActionEvent.doubleCheck}
        message={confirmMessage}
        action={onConfirmAction} />
{/if}

<Toast />

{#if upgradeStorage && user}
    <Upgrade
        {user}
        {api}
        step={upgradeStorage}
        on:showFaqQuestion={showFaqQuestion}
        on:cancel={() => (upgradeStorage = undefined)} />
{/if}

{#if modal !== ModalType.None}
    <Overlay
        dismissible={modal !== ModalType.SelectChat}
        alignLeft={modal === ModalType.SelectChat}
        on:close={closeModal}>
        {#if modal === ModalType.Faq}
            <FaqModal bind:question={faqQuestion} on:close={closeModal} />
        {:else if modal === ModalType.Roadmap}
            <RoadmapModal on:close={closeModal} />
        {:else if modal === ModalType.About}
            <AboutModal canister={{ id: userId, wasmVersion }} on:close={closeModal} />
        {:else if modal === ModalType.SelectChat}
            <SelectChatModal
                chatsSummaries={filterChatSelection(
                    $chatSummariesListStore,
                    $selectedChatStore?.chatId
                )}
                on:close={onCloseSelectChat}
                on:select={onSelectChat} />
        {/if}
    </Overlay>
{/if}

<BackgroundLogo
    width={`${bgHeight}px`}
    bottom={"unset"}
    left={"0"}
    opacity={"0.1"}
    skew={"5deg"}
    viewBox={`0 0 361 ${bgClip}`} />

<style type="text/scss">
    :global(.edited-msg) {
        @include font(light, normal, fs-70);
    }

    main {
        transition: max-width ease-in-out 150ms;
        position: relative;
        width: 100%;
        display: flex;
        gap: $sp3;
        margin: 0 auto;

        &:not(.old-layout) {
            max-width: 1400px;
            @include size-above(xl) {
                max-width: 1792px;
            }
        }

        &.old-layout {
            max-width: 1600px;
            @include size-below(xl) {
                max-width: 1400px;
            }
        }
    }
    :global(body) {
        transition: color ease-in-out 150ms, padding ease-in-out 150ms;
        padding: $sp4;
        --background-color: var(--theme-background);
        --text-color: var(--theme-text);
        color: var(--theme-text);

        @include size-below(lg) {
            padding: $sp3;
        }

        @include mobile() {
            padding: 0;
        }
    }

    :global(body.fill) {
        transition: none;
        padding: 0;
    }

    .right-wrapper {
        position: absolute;
        top: 0;
        &:not(.rtl) {
            right: 0;
        }
        &.rtl {
            left: 0;
        }
        @include z-index("right-panel");
        @include box-shadow(3);
        @include mobile() {
            width: 100%;
            height: 100%;
        }
    }
</style>
