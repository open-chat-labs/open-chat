import "../../../libraries/types/can.did";

type ReplyContextArgs =
    record {
        message_id: MessageId;
    };

type SendMessageArgs =
    record {
        message_id: MessageId;
        content: MessageContent;
        replies_to: opt ReplyContextArgs;
    };

type SendMessageResponse =
    variant {
        Success: record {
            chat_summary: GroupChatSummary;
            message_index: MessageIndex;
            timestamp: TimestampMillis;
        };
        RecipientNotFound;
        BalanceExceeded;
        MessageTooLong: nat32;
        InvalidRequest;
        SenderBlocked;
        RecipientBlocked;
    }; 

type MarkReadArgs =
    record {
        up_to_message_index: MessageIndex;
    };

type MarkReadResponse =
    variant {
        Success;
        SuccessNoChange;
        NotInGroup;
    };

type SetAvatarArgs =
    record {
        mime_type: text;
        bytes: vec nat8;
    };

type SetAvatarResponse =
    variant {
        Success;
        FileTooBig: nat32;
        InvalidMimeType: nat32;
    };

type JoinGroupArgs =
    record {
        "principal": principal;
    };

type JoinGroupResponse =
    variant {
        Success: record {};
        AlreadyInGroup;
        GroupNotPublic;
        Blocked;
    }; 

// TODO
type BlockUserArgs =
    record {
    };

// TODO
type BlockUserResponse =
    variant {
        Success;
    }; 

// TODO
type UnblockUserArgs =
    record {
    };

// TODO
type UnblockUserResponse =
    variant {
        Success;
    }; 

type AddParticipantsArgs =
    record {
        user_ids: vec UserId;
    };

type AddParticipantsResponse =
    variant {
        Success;
        PartialSuccess: AddParticipantsPartialSuccessResult;
        Failed: AddParticipantsFailedResult;
        NotInGroup;
        NotAuthorized;
    };

type AddParticipantsPartialSuccessResult =
    record {
        users_added: vec UserId;
        users_already_in_group: vec UserId;
        users_blocked_from_group: vec UserId;
        users_who_blocked_request: vec UserId;
        errors: vec UserId;
    };

type AddParticipantsFailedResult =
    record {
        users_already_in_group: vec UserId;
        users_blocked_from_group: vec UserId;
        users_who_blocked_request: vec UserId;
        errors: vec UserId;
    };

// TODO
type RemoveParticipantsArgs =
    record {
    };

// TODO
type RemoveParticipantsResponse =
    variant {
        Success;
    }; 

// TODO
type MakeAdminArgs =
    record {
    };

// TODO
type MakeAdminResponse =
    variant {
        Success;
    }; 

// TODO
type RemoveAdminArgs =
    record {
    };

// TODO
type RemoveAdminResponse =
    variant {
        Success;
    }; 

// TODO
type LeaveGroupArgs =
    record {
    };

// TODO
type LeaveGroupResponse =
    variant {
        Success;
    }; 

type PutChunkArgs =
    record {
        blob_id: nat;
        index: nat32;
        bytes: vec nat8;
    };

type PutChunkResponse =
    variant {
        Success;
        Full;
    };

type SummaryArgs =
    record {
    };

type SummaryResponse =
    variant {
        Success: GroupChatSummary;
        SuccessNoUpdates;
        NotInGroup;
    };

type SummaryUpdatesArgs =
    record {
        updates_since: TimestampMillis;
    };

type SummaryUpdatesSuccess =
    record {
        updates: GroupChatSummaryUpdates;
    };

type SummaryUpdatesResponse =
    variant {
        Success: SummaryUpdatesSuccess;
        SuccessNoUpdates;
        NotInGroup;
    };

type GetChunkArgs =
    record {
        blob_id: nat;
        index: nat32;
    };

type GetChunkResponse =
    variant {
        Success: record {
            bytes: vec nat8;
        };
        NotFound;
    };

type EventsArgs =
    record {
        from_index: EventIndex;
        to_index: EventIndex;
    };

type EventsSuccessResult =
    record {
        events: vec GroupChatEventWrapper;
        latest_event_index: EventIndex;
    };

type EventsResponse =
    variant {
        Success: EventsSuccessResult;
        ChatNotFound;
    }; 

type EventsByIndexArgs =
    record {
        events: vec GroupChatEventWrapper;
    };

type EventsByIndexResponse =
    variant {
        Success: EventsSuccessResult;
        ChatNotFound;
    }; 

type SearchMessagesArgs =
    record {
        search_term: text;
        max_results: nat8;
    };

type SearchMessagesResponse =
    variant {
        Success: record {
            matches: vec record {
                message: GroupMessage;
                score: nat32;
            };
        };
        Failure;
    }; 

type MetricsArgs =
    record {
    };

type MetricsResponse = 
    record {
        text_message_count: nat64;
        image_message_count: nat64;
        video_message_count: nat64;
        file_message_count: nat64;
        cycles_balance: int64;
        bytes_used: nat64;
        blob_bytes_used: nat64;
        chunk_count: nat32;
        timestamp: TimestampMillis;
        caller_id: principal;
        wasm_memory_used: nat64;
    };

service: {
    send_message: (SendMessageArgs) -> (SendMessageResponse);
    mark_read: (MarkReadArgs) -> (MarkReadResponse);

    // Admin only
    set_avatar: (SetAvatarArgs) -> (SetAvatarResponse);

    // Public only
    join_group: (JoinGroupArgs) -> (JoinGroupResponse);
    
    // Admin only - public only
    block_user: (BlockUserArgs) -> (BlockUserResponse); 

    // Admin only - public only
    unblock_user: (UnblockUserArgs) -> (UnblockUserResponse);

    add_participants: (AddParticipantsArgs) -> (AddParticipantsResponse);

    // Admin only - Private only
    remove_participants: (RemoveParticipantsArgs) -> (RemoveParticipantsResponse);

    // Admin only
    make_admin: (MakeAdminArgs) -> (MakeAdminResponse);

    // Admin only
    remove_admin: (RemoveAdminArgs) -> (RemoveAdminResponse);

    leave_group: (LeaveGroupArgs) -> (LeaveGroupResponse);

    put_chunk: (PutChunkArgs) -> (PutChunkResponse);

    summary: (SummaryArgs) -> (SummaryResponse) query;
    summary_updates: (SummaryUpdatesArgs) -> (SummaryUpdatesResponse) query;

    events: (EventsArgs) -> (EventsResponse) query;
    events_by_index: (EventsByIndexArgs) -> (EventsByIndexResponse) query;

    // Use Tantivy
    search_messages: (SearchMessagesArgs) -> (SearchMessagesResponse) query;
    
    get_chunk: (GetChunkArgs) -> (GetChunkResponse) query;
    metrics: (MetricsArgs) -> (MetricsResponse) query;
}