// This is the canister for an individual user.
// It holds all the user's direct chats and links to their group chats.
// For now it also holds the file data for any direct messages sent by the user.

type TimestampMillis = nat64;
type CanisterId = principal;
type UserId = CanisterId;
type DirectChatId = principal;
type GroupId = CanisterId;
type EventIndex = nat32;
type MessageIndex = nat32;
type MessageId = nat;

type EventWrapper =
    record {
        index: EventIndex;
        timestamp: TimestampMillis;
        event: DirectChatEvent;
    };

type DirectChatEvent =
    variant {
        Message: DirectMessage;
    };

type TextContent =
    record {
        text: text;
    };

type BlobReference = 
    record {
        canister_id: CanisterId;
        blob_id: text;
        blob_size: nat32;
        chunk_size: nat32;
    };

type MediaContent =
    record {
        width: nat32;
        height: nat32;
        thumbnail_data: text;
        caption: opt text;
        mime_type: text;
        blob_reference: opt BlobReference;
    };

type FileContent =
    record {
        name: text;
        caption: opt text;
        mime_type: text;
        blob_reference: opt BlobReference;
    };

type CyclesContent =
    record {
        amount: nat;
        caption: opt text;
    };

type MessageContent =
    variant {
        Text: TextContent;
        Media: MediaContent;
        File: FileContent;
        Cycles: CyclesContent;
    };

type PrivateReplyDetails =
    record {
        group_chat_id: GroupId;
        user_id: UserId;
        content: MessageContent;
    };

type DirectReplyContext =
    variant {
        Standard: record {
            message_index: MessageIndex;
            sent_by_me: bool;
            content: MessageContent;
        };
        Private: record {
            chat_id: GroupId;
            message_index: MessageIndex;
        };
    };

type GroupReplyContext =
    record {
        event_index: EventIndex;
        user_id: UserId;
        content: MessageContent;
    };

type DirectMessage =
    record {
        message_index: MessageIndex;
        message_id: MessageId;
        timestamp: TimestampMillis;
        sender: UserId;
        content: MessageContent;
        replies_to: opt DirectReplyContext;
    };

type GroupMessage =
    record {
        message_index: MessageIndex;
        message_id: MessageId;
        sender: UserId;
        content: MessageContent;
        replies_to: opt GroupReplyContext;
    };

type ReplyContextArgs =
    record {
        chat_id_if_other: opt GroupId;
        message_index: MessageIndex;
    };

type SendMessageArgs =
    record {
        recipient: UserId;
        sender_name: text;
        message_id: MessageId;
        content: MessageContent;
        replies_to: opt ReplyContextArgs;
    };

type SendMessageResponse =
    variant {
        Success: record {
            message_index: MessageIndex;
            timestamp: TimestampMillis;
            latest_read_by_me: MessageIndex;
            latest_read_by_them: MessageIndex;
        };
        RecipientNotFound;
        BalanceExceeded;
        MessageTooLong: nat32;
        InvalidRequest;
        SenderBlocked;
        RecipientBlocked;
    }; 

type MarkReadArgs =
    record {
        user_id: UserId;
        up_to_message_index: MessageIndex;
    };

type MarkReadResponse =
    variant {
        Success;
        SuccessNoChange;
        ChatNotFound;
        NotAuthorized;
    }; 

type SetAvatarArgs =
    record {
        mime_type: text;
        bytes: vec nat8;
    };

type SetAvatarResponse =
    variant {
        Success;
        FileTooBig: nat32;
        InvalidMimeType: nat32;
    }; 

type BlockUserArgs =
    record {
        user_id: UserId;        
    };

type UnblockUserArgs =
    record {
        user_id: UserId;        
    };

type PutChunkArgs =
    record {
        blob_id: nat;
        index: nat32;
        bytes: vec nat8;
    };

type PutChunkResponse =
    variant {
        Success;
        Full;
    }; 

type CreateGroupArgs =
    record {
        name: text;
        is_public: bool;
    };

type CreateGroupResponse =
    variant {
        Success: record {
            canister_id: CanisterId;
        };
        PublicGroupAlreadyExists;
        GroupLimitExceeded: nat16;
        InvalidName;
        NameTooLong: nat16;
        UnknownError;
    };

type JoinGroupArgs =
    record {
        group_chat_id: GroupId;
    };

type JoinGroupResponse =
    variant {
        Success;
        AlreadyInGroup;
        GroupNotFound;
        GroupNotPublic;
        Blocked;
        NotAuthorized;
        InternalError: text;
    };

type GroupChatUpdatesSince =
    record {
        chat_id: GroupId;
        updates_since: EventIndex;
    };

type UpdatesSince =
    record {
        direct_chats: TimestampMillis;
        group_chats: vec GroupChatUpdatesSince;
    };

type UpdatesArgs = 
    record {
        updates_since: opt UpdatesSince;
    };

type Participant =
    record {
        user_id: UserId;
        date_added: TimestampMillis;
        role: variant {
            Standard;
            Admin;
        };
    };

type UpdatedChatSummary =
    variant {
        Direct: UpdatedDirectChatSummary;
        Group: UpdatedGroupChatSummary;
    };

type UpdatedDirectChatSummary =
    record {
        chat_id: DirectChatId;
        last_updated: TimestampMillis;
        latest_read_by_me: opt MessageIndex;
        latest_read_by_them: opt MessageIndex;
        latest_message: opt EventWrapper;
        latest_event_index: EventIndex;
    };

type UpdatedGroupChatSummary =
    record {
        chat_id: GroupId;
        last_updated: TimestampMillis;
        name: opt text;
        description: opt text;
        latest_read_by_me: opt MessageIndex;
        latest_message: opt EventWrapper;
        participants_removed: vec UserId;
        participants_added: vec Participant;
        participants_updated: vec Participant;
        latest_event_index: EventIndex;
    };

type UpdatesResponse =
    variant {
        Success: record {
            timestamp: TimestampMillis;
            chats_added: vec ChatSummary;
            chats_updated: vec UpdatedChatSummary;
            chats_removed: vec ChatId;
        }
    };

type ChatSummary =
    variant {
        Direct: DirectChatSummary;
        Group: GroupChatSummary;
    };

type DirectChatSummary =
    record {
        chat_id: DirectChatId;
        them: UserId;
        latest_message: record {
            index: EventIndex;
            timestamp: TimestampMillis;
            event: DirectMessage;
        };
        latest_event_index: EventIndex;
        date_created: TimestampMillis;
        latest_read_by_me: MessageIndex;
        latest_read_by_them: MessageIndex;
        last_updated: TimestampMillis;
    };

type GroupChatSummary =
    record {
        chat_id: GroupId;
        name: text;
        description: text;
        is_public: bool;
        min_visible_message_index: MessageIndex;
        participants: vec Participant;
        latest_message: opt record {
            index: EventIndex;
            timestamp: TimestampMillis;
            event: GroupMessage;
        };
        latest_event_index: EventIndex;
        latest_read_by_me: MessageIndex;
        joined: TimestampMillis;
        last_updated: TimestampMillis;
    };

type ChatId =
    variant { 
        Direct: DirectChatId; 
        Group: GroupId; 
    };

type EventsSuccessResult =
    record {
        events: vec EventWrapper;
        latest_event_index: EventIndex;
    };

type EventsArgs =
    record {
        user_id: UserId;
        from_index: EventIndex;
        to_index: EventIndex;
    };

type EventsResponse =
    variant {
        Success: EventsSuccessResult;
        ChatNotFound;
        NotAuthorised;
    };

type EventsByIndexArgs =
    record {
        user_id: UserId;
        events: vec EventIndex;
    };

type EventsByIndexResponse =
    variant {
        Success: EventsSuccessResult;
        ChatNotFound;
    }; 

type SearchAllMessagesArgs =
    record {
        search_term: text;
        max_results: nat8;
    };

type SearchAllMessagesResponse =
    variant {
        Success: record {
            matches: vec record {
                is_direct: bool;
                chat: CanisterId;
                message: DirectMessage;
            };
        };
        Failure;
    }; 

type ChunkArgs =
    record {
        blob_id: nat;
        index: nat32;
    };

type ChunkResponse =
    variant {
        Success: record {
            bytes: vec nat8;
        };
        NotFound;
    };

type HandleAddToGroupRequestedArgs =
    record {
        added_by: UserId;
    };

type HandleAddToGroupRequestedResponse =
    variant {
        Success: HandleAddToGroupRequestedSuccessResult;
        Blocked;
    };

type HandleAddToGroupRequestedSuccessResult =
    record {
        "principal": principal;
    };

type HandleMarkReadArgs =
    record {
        up_to_message_index: MessageIndex;
    };

type HandleMarkReadResponse =
    variant {
        Success;
        SuccessNoChange;
        ChatNotFound;
    };

type HandleMessageReceivedArgs =
    record {
        message_id: MessageId;
        sender_name: text;
        content: MessageContent;
        replies_to: opt ReplyContextArgs;
    };

type HandleMessageReceivedResponse =
    variant {
        Success;
    };

type MetricsArgs =
    record {
    };

type MetricsResponse = 
    record {
        direct_chat_count: nat32;
        group_chat_count: nat32;
        text_message_count: nat64;
        image_message_count: nat64;
        video_message_count: nat64;
        file_message_count: nat64;
        cycles_message_count: nat64;
        cycles_balance: int64;
        bytes_used: nat64;
        blob_bytes_used: nat64;
        chunk_count: nat32;
        timestamp: TimestampMillis;
        caller_id: principal;
        wasm_memory_used: nat64;
    };

type InitArgs = 
    record {
        owner: principal;
        notification_canister_ids: vec CanisterId;
    };

service: (InitArgs) -> {
    send_message: (SendMessageArgs) -> (SendMessageResponse);
    mark_read: (MarkReadArgs) -> (MarkReadResponse);
    set_avatar: (SetAvatarArgs) -> (SetAvatarResponse);
    block_user: (BlockUserArgs) -> ();
    unblock_user: (UnblockUserArgs) -> ();
    put_chunk: (PutChunkArgs) -> (PutChunkResponse);
    create_group: (CreateGroupArgs) -> (CreateGroupResponse);
    join_group: (JoinGroupArgs) -> (JoinGroupResponse);
    
    events: (EventsArgs) -> (EventsResponse) query;
    events_by_index: (EventsByIndexArgs) -> (EventsByIndexResponse) query;
    updates: (UpdatesArgs) -> (UpdatesResponse) query;

    handle_add_to_group_requested: (HandleAddToGroupRequestedArgs) -> (HandleAddToGroupRequestedResponse);
    handle_mark_read: (HandleMarkReadArgs) -> (HandleMarkReadResponse);
    handle_message_received: (HandleMessageReceivedArgs) -> (HandleMessageReceivedResponse);

    // Use ICQC to search all group chats too - use Tantivy. How to resolve filter/sort/page across multiple groups?
    search_all_messages: (SearchAllMessagesArgs) -> (SearchAllMessagesResponse) query;
    chunk: (ChunkArgs) -> (ChunkResponse) query;
    metrics: (MetricsArgs) -> (MetricsResponse) query;
}