<script lang="ts">
    import Close from "svelte-material-icons/Close.svelte";
    import Send from "svelte-material-icons/Send.svelte";
    import HoverIcon from "../HoverIcon.svelte";
    import FileAttacher from "./FileAttacher.svelte";
    import AudioAttacher from "./AudioAttacher.svelte";
    import { emojiStore } from "../../stores/emoji";
    import { createEventDispatcher } from "svelte";
    import { _ } from "svelte-i18n";
    import Progress from "../Progress.svelte";
    import type { ChatController } from "../../fsm/chat.controller";
    import { iconSize } from "../../stores/iconSize";
    import { ScreenWidth, screenWidth } from "../../stores/screenDimensions";
    import Smiley from "./Smiley.svelte";
    import { audioRecordingMimeType } from "../../utils/media";

    export let controller: ChatController;
    export let blocked: boolean;

    $: textContent = controller.textContent;
    $: editingEvent = controller.editingEvent;
    $: fileToAttach = controller.fileToAttach;

    const USER_TYPING_EVENT_MIN_INTERVAL_MS = 1000; // 1 second
    const MARK_TYPING_STOPPED_INTERVAL_MS = 5000; // 5 seconds

    const dispatch = createEventDispatcher();
    let inp: HTMLDivElement;
    let audioMimeType = audioRecordingMimeType();
    export let showEmojiPicker = false;
    let selectedRange: Range | undefined;
    let dragging: boolean = false;
    let recording: boolean = false;
    let percentRecorded: number = 0;
    let initialisedEdit: boolean = false;
    let lastTypingUpdate: number = 0;
    let typingTimer: number | undefined = undefined;
    let messageIsEmpty = true;

    $: {
        if ($editingEvent && !initialisedEdit) {
            if ($editingEvent.event.content.kind === "text_content") {
                inp.textContent = $editingEvent.event.content.text;
                selectedRange = undefined;
                restoreSelection();
                initialisedEdit = true;
            }
        } else if (inp) {
            const text = $textContent ?? "";
            // Only set the textbox text when required rather than every time, because doing so sets the focus back to
            // the start of the textbox on some devices.
            if (inp.textContent !== text) {
                inp.textContent = text;
            }
        }
        if ($editingEvent === undefined) {
            initialisedEdit = false;
        }
    }

    $: {
        if ($fileToAttach !== undefined) {
            inp.focus();
        }
    }

    $: {
        if (controller && $screenWidth === ScreenWidth.Large) {
            inp?.focus();
        }
    }

    function onInput() {
        let inputIsEmpty = (inp.textContent?.trim().length ?? 0) === 0;
        messageIsEmpty = inputIsEmpty && $fileToAttach === undefined;
        controller.setTextContent(inputIsEmpty ? undefined : inp.textContent!);

        requestAnimationFrame(() => {
            const now = Date.now();
            if (now - lastTypingUpdate > USER_TYPING_EVENT_MIN_INTERVAL_MS) {
                lastTypingUpdate = now;
                controller.startTyping();
            }
            if (typingTimer !== undefined) {
                clearTimeout(typingTimer);
            }

            typingTimer = setTimeout(
                () => controller.stopTyping(),
                MARK_TYPING_STOPPED_INTERVAL_MS
            );
        });
    }

    function keyPress(e: KeyboardEvent) {
        if (e.key === "Enter" && !e.shiftKey) {
            if (!messageIsEmpty) {
                sendMessage();
                controller.stopTyping();
            }
            e.preventDefault();
        }
    }

    function sendMessage() {
        dispatch("sendMessage", inp.textContent?.trim());
        inp.textContent = "";
        inp.focus();
        messageIsEmpty = true;
        showEmojiPicker = false;
    }

    function toggleEmojiPicker() {
        showEmojiPicker = !showEmojiPicker;
    }

    function saveSelection() {
        try {
            // seeing errors in the logs to do with this
            selectedRange = window.getSelection()?.getRangeAt(0);
        } catch (_err) {}
    }

    function restoreSelection() {
        inp.focus();
        if (!selectedRange) {
            const range = new Range();
            range.selectNodeContents(inp);
            range.collapse(false);
            selectedRange = range;
        }

        const selection = window.getSelection()!;
        selection.removeAllRanges();
        selection.addRange(selectedRange);
    }

    function onDrop(e: DragEvent) {
        dragging = false;
        dispatch("drop", e);
    }

    function clearAttachment() {
        controller.clearAttachment();
    }

    $: {
        if ($emojiStore !== undefined) {
            if (inp) {
                restoreSelection();
                document.execCommand("insertText", false, $emojiStore);
                saveSelection();
                emojiStore.set(undefined);
            }
        }
    }

    // todo - doubt this will react properly
    $: placeholder =
        $fileToAttach !== undefined
            ? $_("enterCaption")
            : dragging
            ? $_("dropFile")
            : $_("enterMessage");
</script>

<div class="message-entry">
    {#if blocked}
        <div class="blocked">
            {$_("userIsBlocked")}
        </div>
    {:else}
        <div class="emoji" on:click={toggleEmojiPicker}>
            {#if showEmojiPicker}
                <HoverIcon>
                    <Close size={$iconSize} color={"var(--icon-txt)"} />
                </HoverIcon>
            {:else}
                <HoverIcon>
                    <Smiley />
                </HoverIcon>
            {/if}
        </div>
        <div class="attach">
            <FileAttacher
                open={$fileToAttach !== undefined}
                on:fileSelected
                on:close={clearAttachment} />
        </div>

        {#if recording}
            <Progress percent={percentRecorded} />
        {/if}
        <div
            tabindex={0}
            bind:this={inp}
            on:blur={saveSelection}
            class="textbox"
            class:recording
            class:dragging
            contenteditable={true}
            on:paste
            {placeholder}
            spellcheck={true}
            on:dragover={() => (dragging = true)}
            on:dragenter={() => (dragging = true)}
            on:dragleave={() => (dragging = false)}
            on:drop={onDrop}
            on:input={onInput}
            on:keypress={keyPress} />
        {#if messageIsEmpty && audioMimeType !== undefined}
            <div class="record">
                <AudioAttacher
                    mimeType={audioMimeType}
                    bind:percentRecorded
                    bind:recording
                    on:audioCaptured />
            </div>
        {:else}
            <div class="send" on:click={sendMessage}>
                <HoverIcon>
                    <Send size={$iconSize} color={"var(--icon-txt)"} />
                </HoverIcon>
            </div>
        {/if}
    {/if}
</div>

<style type="text/scss">
    .message-entry {
        position: relative;
        flex: 0 0 40px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: var(--entry-bg);
        padding: $sp3;
    }
    .emoji,
    .attach,
    .send {
        flex: 0 0 15px;
    }
    .textbox {
        flex: 1;
        margin: 0 $sp3;
        padding: 6px $sp4;
        background-color: var(--entry-input-bg);
        color: var(--entry-input-txt);
        border-radius: 20px;
        outline: none;
        border: 0;
        max-height: 100px;
        min-height: 30px;
        overflow-x: hidden;
        overflow-y: auto;
        user-select: text;
        white-space: pre-wrap;
        overflow-wrap: anywhere;
        border: 1px solid transparent;
        @include font(book, normal, fs-100);

        &:empty:before {
            content: attr(placeholder);
            color: var(--placeholder);
            pointer-events: none;
            display: block; /* For Firefox */
        }

        &.dragging {
            border: 1px dashed var(--entry-input-txt);
        }

        &.recording {
            display: none;
        }
    }

    .blocked {
        height: 42px;
        color: var(--entry-input-txt);
        @include font(book, normal, fs-100);
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
    }
</style>
