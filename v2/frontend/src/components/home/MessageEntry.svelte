<script lang="ts">
    import EmoticonHappyOutline from "svelte-material-icons/EmoticonHappyOutline.svelte";
    import Close from "svelte-material-icons/Close.svelte";
    import Send from "svelte-material-icons/Send.svelte";
    import HoverIcon from "../HoverIcon.svelte";
    import { onMount } from "svelte";
    import FileAttacher from "./FileAttacher.svelte";
    import AudioAttacher from "./AudioAttacher.svelte";
    import { emojiStore } from "../../stores/emoji";
    import { createEventDispatcher } from "svelte";
    import { _ } from "svelte-i18n";
    import Progress from "../Progress.svelte";
    import type { ChatController } from "../../fsm/chat.controller";
    import { ScreenWidth, screenWidth } from "../../stores/screenWidth";

    export let controller: ChatController;
    export let blocked: boolean;

    $: iconSize = $screenWidth === ScreenWidth.ExtraSmall ? "1.2em" : "1.5em";
    $: editingEvent = controller.editingEvent;
    $: fileToAttach = controller.fileToAttach;

    const USER_TYPING_EVENT_MIN_INTERVAL_MS = 1000; // 1 second
    const MARK_TYPING_STOPPED_INTERVAL_MS = 5000; // 5 seconds

    const dispatch = createEventDispatcher();
    let inp: HTMLDivElement;
    export let showEmojiPicker = false;
    let selectedRange: Range | undefined;
    let dragging: boolean = false;
    let recording: boolean = false;
    let percentRecorded: number = 0;
    let initialisedEdit: boolean = false;
    let lastTypingUpdate: number = 0;
    let typingTimer: number | undefined = undefined;

    $: {
        if ($editingEvent && !initialisedEdit) {
            if ($editingEvent.event.content.kind === "text_content") {
                inp.textContent = $editingEvent.event.content.text;
                selectedRange = undefined;
                restoreSelection();
                initialisedEdit = true;
            }
        }
        if ($editingEvent === undefined) {
            initialisedEdit = false;
        }
    }

    onMount(() => {
        if (inp) {
            inp.focus();
        }
    });

    function onInput() {
        requestAnimationFrame(() => {
            const now = Date.now();
            if (now - lastTypingUpdate > USER_TYPING_EVENT_MIN_INTERVAL_MS) {
                lastTypingUpdate = now;
                controller.startTyping();
            }
            if (typingTimer !== undefined) {
                clearTimeout(typingTimer);
            }

            typingTimer = setTimeout(
                () => controller.stopTyping(),
                MARK_TYPING_STOPPED_INTERVAL_MS
            );
        });
    }

    function keyPress(e: KeyboardEvent) {
        if (e.key === "Enter" && !e.shiftKey) {
            sendMessage();
            controller.stopTyping();
            e.preventDefault();
        }
    }

    function sendMessage() {
        dispatch("sendMessage", inp.textContent);
        inp.textContent = "";
        showEmojiPicker = false;
    }

    function toggleEmojiPicker() {
        showEmojiPicker = !showEmojiPicker;
    }

    function saveSelection() {
        selectedRange = window.getSelection()?.getRangeAt(0);
    }

    function restoreSelection() {
        inp.focus();
        if (!selectedRange) {
            const range = new Range();
            range.selectNodeContents(inp);
            range.collapse(false);
            selectedRange = range;
        }

        const selection = window.getSelection()!;
        selection.removeAllRanges();
        selection.addRange(selectedRange);
    }

    function onDrop(e: DragEvent) {
        dragging = false;
        dispatch("drop", e);
    }

    function clearAttachment() {
        controller.clearAttachment();
    }

    $: {
        if ($emojiStore !== undefined) {
            if (inp) {
                restoreSelection();
                document.execCommand("insertText", false, $emojiStore);
                saveSelection();
                emojiStore.set(undefined);
            }
        }
    }

    // TODO - do we even want to focus the input - it's quite distracting on mobile
    // $: {
    //     if (
    //         $machine.changed &&
    //         ($machine.context.replyingTo !== undefined ||
    //             $machine.context.fileToAttach !== undefined)
    //     ) {
    //         inp.focus();
    //     }
    // }

    // todo - doubt this will react properly
    $: placeholder =
        $fileToAttach !== undefined
            ? $_("enterCaption")
            : dragging
            ? $_("dropFile")
            : $_("enterMessage");
</script>

<div class="message-entry">
    {#if blocked}
        <div class="blocked">
            {$_("userIsBlocked")}
        </div>
    {:else}
        <div class="emoji" on:click={toggleEmojiPicker}>
            {#if showEmojiPicker}
                <HoverIcon>
                    <Close size={iconSize} color={"var(--icon-txt)"} />
                </HoverIcon>
            {:else}
                <HoverIcon>
                    <EmoticonHappyOutline size={iconSize} color={"var(--icon-txt)"} />
                </HoverIcon>
            {/if}
        </div>
        <div class="attach">
            <FileAttacher
                open={$fileToAttach !== undefined}
                on:fileSelected
                on:close={clearAttachment} />
        </div>

        {#if recording}
            <Progress percent={percentRecorded} />
        {/if}
        <div
            tabindex={0}
            bind:this={inp}
            on:blur={saveSelection}
            class="textbox"
            class:recording
            class:dragging
            contenteditable={true}
            on:paste
            {placeholder}
            spellcheck={true}
            on:dragover={() => (dragging = true)}
            on:dragenter={() => (dragging = true)}
            on:dragleave={() => (dragging = false)}
            on:drop={onDrop}
            on:input={onInput}
            on:keypress={keyPress} />
        <div class="record">
            <AudioAttacher bind:percentRecorded bind:recording on:audioCaptured />
        </div>
        <div class="send" on:click={sendMessage}>
            <HoverIcon>
                <Send size={iconSize} color={"var(--icon-txt)"} />
            </HoverIcon>
        </div>
    {/if}
</div>

<style type="text/scss">
    .message-entry {
        position: relative;
        flex: 0 0 40px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: var(--entry-bg);
        border-top: 1px solid var(--entry-bd);
        padding: $sp3;
    }
    .emoji,
    .attach,
    .send {
        flex: 0 0 15px;
    }
    .textbox {
        flex: 1;
        margin: 0 $sp3;
        padding: $sp3 $sp4;
        background-color: var(--entry-input-bg);
        color: var(--entry-input-txt);
        border-radius: 20px;
        outline: none;
        border: 0;
        max-height: 100px;
        min-height: 30px;
        overflow-x: hidden;
        overflow-y: auto;
        user-select: text;
        white-space: pre-wrap;
        overflow-wrap: anywhere;
        border: 1px solid transparent;
        @include font(book, normal, fs-100);

        &:empty:before {
            content: attr(placeholder);
            color: #ccc;
            pointer-events: none;
            display: block; /* For Firefox */
        }

        &.dragging {
            border: 1px dashed var(--entry-input-txt);
        }

        &.recording {
            display: none;
        }
    }

    .blocked {
        height: 42px;
        color: var(--entry-input-txt);
        @include font(book, normal, fs-100);
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
    }
</style>
