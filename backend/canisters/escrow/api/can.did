type CanisterId = principal;
type ChannelId = nat32;
type ChatId = CanisterId;
type CommunityId = CanisterId;
type MessageId = nat64;
type MessageIndex = nat32;
type TimestampMillis = nat64;

type OCError = record { nat16; opt text; };

type Account = record{
    owner: principal;
    subaccount: opt blob;
};

type Chat = variant {
    Direct : ChatId;
    Group : ChatId;
    Channel : record { CommunityId; ChannelId };
};

type TokenInfo = record {
    symbol : text;
    ledger : CanisterId;
    decimals : nat8;
    fee : nat;
};

type P2PSwapLocation = variant {
    Message : Message;
    External;
};

type Message = record {
    chat : Chat;
    thread_root_message_index : opt MessageIndex;
    message_id : MessageId;
};

type CreateSwapArgs = record {
    // Specifies whether the swap is associated with an OpenChat message or is External.
    location : P2PSwapLocation;

    // The token to be deposited by the offerer of the swap.
    token0 : TokenInfo;

    // The amount of token0 to be deposited.
    token0_amount : nat;

    // The principal of the party offering the swap. If this is not specified then the caller's principal is used.
    token0_principal : opt principal;

    // The token to be deposited by the accepter of the swap.
    token1 : TokenInfo;

    // The amount of token1 to be deposited.
    token1_amount : nat;

    // The principal of the party who can accept the swap. If this is not specified then anyone can accept the swap.
    token1_principal : opt principal;

    // The swap will expire after this timestamp.
    expires_at : TimestampMillis;

    // The principals of parties other than the offerer who can cancel the swap.
    additional_admins : vec principal;

    // If specified, this canister will be notified when the status of the swap has changed.
    canister_to_notify : opt CanisterId;
};

type CreateSwapResponse = variant {
    Success : record {
        id : nat32;
        token0_deposit_account: Account;
        token1_deposit_account: opt Account;
    };
    InvalidSwap : text;
    Error : OCError;
};

type CancelSwapArgs = record {
    swap_id : nat32;
};

type CancelSwapResponse = variant {
    Success;
    SwapAlreadyAccepted;
    SwapExpired;
    SwapNotFound;
    NotAuthorized;
    Error : OCError;
};

type NotifyDepositArgs = record {
    swap_id : nat32;

    // The principal of the party whose tokens have been deposited
    deposited_by : opt principal;
};

type NotifyDepositResponse = variant {
    Success : record {
        complete : bool;
    };
    BalanceTooLow : record {
        balance : nat;
        balance_required : nat;
    };
    SwapAlreadyAccepted;
    SwapCancelled;
    SwapExpired;
    SwapNotFound;
    NotAuthorized;
    InternalError : text;
    Error : OCError;
};

type LookupSwapArgs = record {
    swap_id : nat32;

    // The principal of the accepting party or the caller if not specified
    accepting_principal : opt principal;
};

type LookupSwapResponse = variant {
    Success: record {
        id : nat32;
        location : P2PSwapLocation;
        created_at : TimestampMillis;
        offered_by : principal;
        restricted_to : opt principal;
        token0 : TokenInfo;
        amount0 : nat;
        token0_deposit_account : Account;
        token1 : TokenInfo;
        amount1 : nat;
        token1_deposit_account : Account;
        expires_at : TimestampMillis;
        additional_admins : vec principal;
        canister_to_notify : opt CanisterId;
    };
    SwapNotFound;
    PrincipalNotFound;
    Error : OCError;
};

service : {
    lookup_swap : (LookupSwapArgs) -> (LookupSwapResponse) query;    
    create_swap : (CreateSwapArgs) -> (CreateSwapResponse);
    cancel_swap : (CancelSwapArgs) -> (CancelSwapResponse);
    notify_deposit : (NotifyDepositArgs) -> (NotifyDepositResponse);
};